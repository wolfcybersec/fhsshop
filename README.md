# FHSS Sequence Generator

This tool replicates the frequency-hopping sequence algorithm used in embedded systems like ExpressLRS, using the same Linear Congruential Generator (LCG) algorithm found on ESP32 firmware. It's useful for reverse-engineering, signal analysis, and debugging drone RF protocols that rely on FHSS.

## üîß Features

- Bit-accurate FHSS sequence generation
- Firmware-compatible RNG (ESP32-style LCG)
- UID generation from numeric phrases or binding strings
- Multiple regional domain support (FCC915, AU915, EU868, IN866)
- Human-readable logging and output
- CLI-friendly, fast, and extensible

## ‚öôÔ∏è How It Works

1. **UID Generation**: Accepts a comma-separated numeric phrase or fallback string to generate a 6-byte UID.
2. **Seed Derivation**: Converts UID into a 32-bit seed using the same logic as ExpressLRS.
3. **RNG**: Uses a firmware-accurate Linear Congruential Generator.
4. **Sequence Builder**:
    - Inserts sync channels at fixed intervals.
    - Pseudo-randomly swaps frequency positions per firmware logic.

## üì¶ Structure

- `generate_uid()` ‚Äì Handles UID derivation
- `compute_seed_from_uid()` ‚Äì Converts UID to PRNG seed
- `FirmwareLCG` ‚Äì Implements ESP32-compatible LCG
- `FHSSGenerator` ‚Äì Builds the 256-hop frequency sequence
- `main()` ‚Äì Parses arguments and prints the sequence

---
## üîç How FHSS Sequences Are Generated in ExpressLRS Firmware

The FHSS (Frequency-Hopping Spread Spectrum) sequence used in ExpressLRS is generated entirely deterministically in the firmware, ensuring the same frequency hopping pattern is reproduced on both transmitter and receiver given the same binding phrase and regulatory domain.

### üì¶ Key Components Involved

The following firmware-level elements are responsible for building the hopping sequence:

### 1. `FHSS_SEQUENCE_LEN`
This defines the total number of hops in a complete FHSS cycle. The default is typically:

```c
#define FHSS_SEQUENCE_LEN 256
```

You can increase this value (e.g. to 512) for a longer sequence. The hopping algorithm uses this to build a fixed-length table of frequency indices.

### 2. `uid_t` or `binding_phrase`
The UID is derived from a binding phrase or manually entered 6-byte value. If the phrase is not explicitly numeric, the UID is computed as:

```cpp
MD5("-DMY_BINDING_PHRASE=\"your_phrase\"") ‚Üí uid[6]
```

This is done with:
```cpp
uid = md5("-DMY_BINDING_PHRASE=\"" + phrase + "\"");
```

In Python, this is reproduced with:
```python
hashlib.md5(f'-DMY_BINDING_PHRASE="{phrase}"'.encode()).digest()[:6]
```

### 3. `GetMacSeedFromUID()`
The seed used to initialize the pseudo-random number generator is computed as:

```c
uint32_t GetMacSeedFromUID(const uint8_t* uid) {
    return ((uid[2] << 24) | (uid[3] << 16) | (uid[4] << 8) | (uid[5] ^ OTA_VERSION_ID));
}
```

This ensures that even with similar UIDs, different OTA versions yield different seeds.

### 4. `rand()` and the LCG
The firmware uses a firmware-compatible **Linear Congruential Generator** (LCG), same as `esp_random()` or `rand()` on ESP32. It follows:

```c
state = (1103515245 * state + 12345) & 0x7FFFFFFF;
```

This generator ensures deterministic pseudorandom values that are reproducible across platforms, allowing the same hop sequence to be used on different devices.

### 5. `BuildFHSSSequence()`
The actual sequence is generated by:
- Pre-filling each `freq_count`-sized block with pseudo-sequential frequencies.
- Placing the **sync channel** at every `i % freq_count == 0` location.
- Performing in-block **swaps** using the PRNG to create randomness within each group.

In pseudocode:

```cpp
for each index i in 0..FHSS_SEQUENCE_LEN:
    if i % freq_count == 0:
        sequence[i] = sync_channel
    else if i % freq_count == sync_channel:
        sequence[i] = 0
    else:
        sequence[i] = i % freq_count

for each i in 0..FHSS_SEQUENCE_LEN:
    if i % freq_count != 0:
        rand_offset = rand() % (freq_count - 1) + 1
        swap sequence[i] with sequence[block_start + rand_offset]
```

This algorithm ensures the sync channel appears regularly, while the rest of the frequencies are randomized but balanced across the domain.

---

### üß† Observations
- The first portion of the sequence (e.g., first 256 values) of a 512-hop sequence will closely match a 256-hop version using the same seed and parameters.
- Only a few values differ due to additional RNG calls beyond the 256 mark.
- Increasing `FHSS_SEQUENCE_LEN` extends the sequence without disrupting the early structure.

---

### üîç Pattern Similarity Between `FHSS_SEQUENCE_LEN = 256` and `512`

- **Matching Prefix**: Out of the first 256 hops in the 512-length sequence, **243 are identical** to the 256-length sequence.  
  ‚Üí That‚Äôs a **94.9% match**, showing strong alignment at the beginning.

- **Cross-Correlation**: A strong peak near the center of the correlation curve confirms significant **overlap in structure and pattern**, especially in the first half of the 512-sequence.

### üß† Why This Happens
- The random number generator (`FirmwareLCG`) is deterministic, and both sequences are built using the **same seed**.
- The shuffle logic is consistent up to index 256 ‚Äî beyond that, the 512-sequence continues while the 256 stops.
- This means **longer sequences are supersets** of shorter ones, up to their length.

---

## üöÄ Installation

Python 3.7+ required.

```bash
git clone https://github.com/wolfcybersec/fhsshop
cd fhss-sequence-generator
pip install -r requirements.txt  # Only if you add deps like numpy
```

This script currently has no external dependencies.

## üß™ Usage

```bash
python3 fhss_gen.py --domain FCC915 --phrase 42,13,9,8
```

### Arguments

| Argument      | Description                                       | Default         |
|---------------|---------------------------------------------------|-----------------|
| `--domain`    | Regulatory domain (FCC915, AU915, EU868, IN866)   | `FCC915`        |
| `--phrase`    | Comma-separated UID phrase or a binding string     | `42,13,9,8`     |

### Example Output

```
[INFO] UID: aabbccddeeff
[INFO] Seed: 283746519
[INFO] Regulatory Domain: FCC915
[INFO] Sync Channel: 20
[INFO] Total Hops: 256
FHSS Sequence (indices):
 0 20  2  3  4  5  6  7  8  9
...
```

---
## üìò Notes

- This tool is meant for reverse-engineering and testbench purposes.
- Output is bit-accurate to what ELRS firmware would generate using the same seed and domain.


## üõ° License

MIT
